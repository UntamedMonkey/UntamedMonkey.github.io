[{"title":"python编程规范","url":"/2023/01/15/python/","content":"# 1.工程结构\n- 保证仓库结构清晰、易读，如示例1.1所示。\n- 代码间低耦合，无循环依赖，少使用全局变量，少写长函数\n- 拆分出文件（模块）、文件夹（包）；合理使用相对import和绝对import\n- 合理使用面向对象、装饰器、with(上下文管理器；示例1.2)等特性，有利于代码解耦。\n  \n```shell\n#例1.1：仓库结构示例\nREADME\nLICENSE\nsetup.py\nrequirements.txt\ncodes/\n\tmodels/\n\tconfigs/\n\tkernels/\n\tutils/\n\ttrainer/\n\tdatas/\n\ttrain.py\n\ttest.py\n\tinference.py\n\tREADME\ndocs/\ntests/\n``` \n```python\n# 例1.2：使用上下文管理的两种方法\n# 定义enter和exit方法实现：\nclass CustomOpen(object):\n    def __init__(self, filename):\n        self.file = open(filename)\n\n    def __enter__(self):\n        return self.file\n\n    def __exit__(self, ctx_type, ctx_value, ctx_traceback):\n        self.file.close()\n\nwith CustomOpen('file') as f:\n    contents = f.read()\n# 使用自带的contextlib实现：\nfrom contextlib import contextmanager\n\n@contextmanager\ndef custom_open(filename):\n    f = open(filename)\n    try:\n        yield f\n    finally:\n        f.close()\n\nwith custom_open('file') as f:\n    contents = f.read()\n```  \n  \n  \n\n\n\n# 2.代码风格\n  - 在存在各种黑魔法的Python中，我们提倡最明确和直接的编码方式\n  - 在同一行代码中写 两条独立的语句是糟糕的。\n  - 少使用*args定义函数参数,因为它不应该被用在能用更简单和更明确的结构，来足够表达函数意图的情况中。\n  - 任何不开放给客户端代码使用的方法或属性，应该有一个下划线前缀。\n  - 函数只有一个出口点，输入、运行环境的检查建议使用异常机制，见例2.1\n  - 可能运行失败的代码使用异常机制（``try...except``）\n  - 使用上下文管理器管理资源\n  - 使用属性，而不是get/set\n  - 使用``_``命名临时变量\n  - 避免对不同类型的对象使用同一个变量名\n  - string类型是不可变类型，减少内存分配，少使用``s+=str(i)``，可以改成：生成list，再join。\n  - 使用 str.format() 替代 % 操作符。例如：``foobar = '{foo}{bar}'.format(foo=foo, bar=bar)``\n  - 使用``in``进行字串匹配\n  - 使用``enumerate()``进行index计数\n  - 使用next()进行按条件查找\n  - 对于可变序列，使用del替代重新分配``del l[j:] instead of l = l[:j]``\n  - 如果您知道一个列表或者元组的长度，您可以将其解包并为它的元素取名。``a, b, *middle, c = [1, 2, 3, 4]``\n  - 使用filter() 函数过滤list：``sequence[::] = list(filter(lambda i: i != x, sequence))``\n  - 修改list，优先考虑赋值为新的list，如：``a = [i + 3 for i in a] or a = list(map(lambda i: i + 3, a))``\n  - 过长的行一个更好的解决方案是在周围使用括号 ``(·····)``\n  - ``pip install autopep8````autopep8 --in-place optparse.py``\n```python\n#例2.1\ndef complex_function(a, b, c):\n    if not a:\n        return None  # 抛出一个异常可能会更好\n    if not b:\n        return None  # 抛出一个异常可能会更好\n\n    # 一些复杂的代码试着用a,b,c来计算x\n    # 如果成功了，抵制住返回x的诱惑\n    if not x:\n        # 一些关于x的计算的Plan-B\n    return x  # 返回值x只有一个出口点有利于维护代码\n```\n```python\n#例2.2\ntry:\n    x = next(i for i, n in enumerate(l) if n > 0)\nexcept StopIteration:\n    print('No positive numbers')\nelse:\n    print('The index of the first positive number is', x)\n```\n```\n# python之禅\n优美胜于丑陋（Python以编写优美的代码为目标）\n明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）\n简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）\n复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）\n扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）\n间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）\n可读性很重要（优美的代码是可读的）\n即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）\n不要包容所有错误，除非您确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）\n当存在多种可能，不要尝试去猜测\n而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）\n虽然这并不容易，因为您不是 Python 之父（这里的 Dutch 是指 Guido ）\n做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）\n如果您无法向人描述您的方案，那肯定不是一个好方案；反之亦然（方案测评标准）\n命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）\n```\n### 参考资料\n[python最佳实践](https://pythonguidecn.readthedocs.io/zh/latest/)","tags":["学习笔记","python"]},{"title":"C++容器总结","url":"/2022/06/03/C++/","content":"\n### [STL简介:](geeksforgeeks.org/the-c-standard-template-library-stl)\nC++的标准模板类库，包含常见数据结构及函数。主要包括:\n+ 容器\n+ 算法\n+ 函数（Functions）\n+ 迭代器\n\n### 1. 容器：\n+ 序列式容器:基本的容器\n   + arrays||at();[];front();back();size();empty();fill()||比C自带的数组好\n   + vector||asign();at();[];front();back();begin();end;size();max_size();capacity();resize(n);empty();shrink_to_fit();push_back();pop_back();insert();erase();clear();\n   + forward_list||assign();push_front();emplace_front();pop_front();insert_after();emplace_after(); erase_after(); remove(); remove_if();clear();\n   + deque\n   + list\n   \n+ 容器适配器:序列式容器的扩展\n   + queue\n   + priority_queue\n   + stack\n+ 关联式容器:非序列式容器，基于自平衡二叉树\n   +  set\n   +  multiset\n   +  map\n   +  multimap\n+ 无序关联式容器:非序列式容器，基于哈希表\n   +  unordered_set\n   +  unordered_multiset\n   +  unordered_map\n   +  unordered_multimap\n\n\n### 2. 算法：\n+ sort(startaddress, endaddress)\n","tags":["学习笔记","算法题"]},{"title":"面试算法刷题总结","url":"/2022/06/03/algo/","content":"# 0. 刷题总结\n- 熟悉常用库函数；熟悉数据结构和算法；提高用程序解决复杂问题的能力；提高编程能力和速度。可以参考：[代码随想录](https://www.programmercarl.com/)；[算法小抄](https://github.com/labuladong/fucking-algorithm)。\n- 代码命名、格式、风格参考最佳实践，提高可读性，降低出错率。可以参考：[python最佳实践](https://pythonguidecn.readthedocs.io/zh/latest/)；[C++风格指南](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/)；[C++最佳实践](https://github.com/cpp-best-practices/cppbestpractices)；[腾讯代码安全指南](https://github.com/Tencent/secguide)。\n\n# 1. 算法总结\n### 1.1 算法技巧\n#### 1.1.1 前缀和数组 \n需要频繁计算数组区间和，且数组固定不变：直接转变为前缀和数组,复杂度O(n)>O(1)  \n  [区域和检索](https://leetcode.cn/problems/range-sum-query-immutable/) | [二维区域和检索](https://leetcode.cn/problems/range-sum-query-2d-immutable/)\n#### 1.1.2 差分数组 \n频繁进行区间修改时维护数组的值：转变为差分数组，复杂度O(n)>O(1)  \n[拼车](https://leetcode.cn/problems/car-pooling/) | [航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)\n#### 1.1.3 链表双指针 \n判断/寻找链表中的交点：使用双指针遍历链表并创造条件让指针相遇，空间复杂度O(n)>O(1)  \n[环形链表](https://leetcode.cn/problems/linked-list-cycle/) | [环形链表2](https://leetcode.cn/problems/linked-list-cycle-ii/) | [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\n#### 1.1.4 数组双指针 \n数组寻找受限极值/特定值：发掘单调性规律，让遍历每一步不回头，时间复杂度O(n)>O(1)  \n[有序数组-两数之和](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/) | [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) | [搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix-ii/) | []()\n#### 1.1.5 滑动窗口 \n寻找满足特定条件的最小字串：控制左右边界缩放，让遍历有序，时间复杂度O(n^2)>O(n)  \n[无重复字符的最长字串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) | [串联所有单词的子串\n](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/) | [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) | [包含排列的子串](https://leetcode.cn/problems/permutation-in-string/) | [最小覆盖字串](https://leetcode.cn/problems/minimum-window-substring/) [最短超串](https://leetcode.cn/problems/shortest-supersequence-lcci/) | [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)\n#### 1.1.6  二分搜索 \n有序数组寻找特定值：利用单调性每次查找时剔除一侧的搜索空间，时间复杂度O(n)>O(log(n))  \n[二分查找](https://leetcode.cn/problems/binary-search/) | [二分查找第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) | [送包裹](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/) | [吃香蕉](https://leetcode.cn/problems/koko-eating-bananas/) | [分割数组最大值](https://leetcode.cn/problems/split-array-largest-sum/)、\n#### 1.1.7  单调栈 \n利用单调栈维护最大值，时间复杂度O(n^2)>O(n)  \n[下一个更大的元素](https://leetcode.cn/problems/next-greater-element-i/) | [下一个更大的元素2](https://leetcode.cn/problems/next-greater-element-ii/) | [每日温度](https://leetcode.cn/problems/daily-temperatures/) | [接雨水](https://leetcode.cn/problems/trapping-rain-water/) | [队列中可以看到的人数](https://leetcode.cn/problems/number-of-visible-people-in-a-queue/) | [链表下一个更大的节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/) | [股票价格的跨度](https://leetcode.cn/problems/online-stock-span/) \n| []()\n#### 1.1.7  单调队列\n利用单调队列维护最大值，时间复杂度O(n)>O(1)     \n[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/) | [环形子数组最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)\n#### 1.1.8 并查集\nbalabala\n[被围绕的区域](https://leetcode.cn/problems/surrounded-regions/) | [并查集](https://leetcode.cn/tag/union-find/problemset/)\n\n\n### 1.2 算法思想\n#### 1.2.1 递归\n[二叉树](https://leetcode.cn/tag/binary-tree/problemset/) | [递归](https://leetcode.cn/tag/recursion/problemset/)[图](https://leetcode.cn/tag/graph/problemset/)\n#### 1.2.2 回溯\n[回溯](https://leetcode.cn/tag/backtracking/problemset/) | [bfs](https://leetcode.cn/tag/breadth-first-search/problemset/) | [dfs](https://leetcode.cn/tag/depth-first-search/problemset/)\n#### 1.2.3 贪心\n[贪心](https://leetcode.cn/tag/greedy/problemset/)\n#### 1.2.4 动态规划\n[动态规划](https://leetcode.cn/tag/dynamic-programming/problemset/)\n\n# 2. 题目记录\n很多题目未必包含精巧/通用的算法，而是需要完整的实现功能或者针对性的复杂度优化  \n\n[翻转数组](https://leetcode.cn/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/)  \n在暴力解法的基础上，利用第一行确定整个矩阵，从而压缩搜索空间，降低复杂度。  \n\n[LRU缓存](https://leetcode.cn/problems/lru-cache/)  \n\n[购物单](https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&tqId=21239&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)  \n动态规划01背包的一个变体，每个物体包含多种可能的选择。  \n\n[求解立方根](https://www.nowcoder.com/practice/caf35ae421194a1090c22fe223357dca?tpId=37&tqId=21330&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fdifficulty%3D3%26page%3D1%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=3&judgeStatus=undefined&tags=&title=)  \n二分法或者牛顿法  \n\n[迷宫](https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc?tpId=37&tqId=21266&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fdifficulty%3D3%26page%3D1%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=3&judgeStatus=undefined&tags=&title=)  \n回溯\n","tags":["学习笔记","算法题"]},{"title":"Hexo Quick Start","url":"/2021/09/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]