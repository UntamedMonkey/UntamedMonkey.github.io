[{"title":"pytorch使用总结","url":"/2022/07/25/pytorch/","content":"运行：[colab notebook](https://colab.research.google.com/drive/1rd-EoeB5iBu55VicbBZYMWp5xxA63VMi#scrollTo=yzA0_qm16zhb)\n1. tensor赋值、常用方法\n\n```python\nimport torch\nimport numpy as np\n\n# numpy转换\na = np.arange(8).reshape((2,4))\ny = (torch.tensor(a, dtype=torch.float32, \n                  requires_grad=False, device='cuda:0'))\nprint(\"y=\", y)\nan = y.cpu().numpy()\nprint(\"an=\", an)\n\n# list转换\nb = [[4 * i + j for j in range(4)] for i in range(2)]\nz = (torch.tensor(b, dtype=torch.float32, \n                  requires_grad=False, device='cpu'))\nprint(\"z=\", z)\n\n# 随机初始化\nu = torch.rand(2,3)\nprint(\"u=\", u)\nv = torch.randn_like(y)\nprint(\"v=\", v)\n\n# 常用方法\nprint(\"y.size:\", y.size())\nprint(\"y.view:\", y.view(-1))\n\n\"\"\" output:\ny= tensor([[0., 1., 2., 3.],\n        [4., 5., 6., 7.]], device='cuda:0')\nan= [[0. 1. 2. 3.]\n [4. 5. 6. 7.]]\n\nz= tensor([[0., 1., 2., 3.],\n        [4., 5., 6., 7.]])\n\nu= tensor([[0.3741, 0.0632, 0.7546],\n        [0.9163, 0.8642, 0.2626]])\nv= tensor([[-0.1389, -0.0200, -0.7156, -0.4071],\n        [-0.0301, -0.3345,  0.4790,  0.1603]], device='cuda:0')\n\ny.size: torch.Size([2, 4])\ny.view: tensor([0., 1., 2., 3., 4., 5., 6., 7.], device='cuda:0')\n\"\"\"\n```\n\n\n2. 利用底层autograd实现linear regression\n```python\nimport torch\nimport numpy as np\n# 训练数据\ngt_w = (torch.tensor(np.array([[6, -0.6, 0.06]]).T, \n                device='cuda:0', dtype=torch.float32))\ngt_b = 6.6\nx = torch.rand(1000, 3).cuda()\ny = torch.mm(x, gt_w) + gt_b\ny = y + torch.rand_like(y) * 10e-3\n# 线性模型的参数\nw = torch.rand(3, 1, requires_grad=True, device='cuda:0')\nb = torch.rand(1, 1, requires_grad=True, device='cuda:0')\n# 梯度下降\nfor i in range(10000):\n  pred = torch.mm(x, w) + b\n  loss = torch.mean((pred-y)*(pred-y))\n  if i%100==99:\n    print(\"{i}th iter loss:\".format(i=i).ljust(18), loss.item())\n  # 计算各节点梯度\n  loss.backward()\n  if loss.item()<10e-6:\n    print(\"final w.grad\", w.grad.cpu().detach().numpy().T[0])\n    break\n  # w,b在此处的计算不能构图，否则会循环 \n  with torch.no_grad():\n    w-=0.25 * w.grad\n    b-=0.25 * b.grad\n    # 每次梯度下降后要置零\n    w.grad.zero_()\n    b.grad.zero_()\nprint(\"gt w =\", gt_w.cpu().detach().numpy().T[0])\nprint(\"gt b =\", gt_b)\nprint(\"learned w =\", w.cpu().detach().numpy().T[0])\nprint(\"learned b =\", b.cpu().detach().numpy()[0][0])\n\n\"\"\"output\n99th iter loss:    0.0023212977685034275\n199th iter loss:   2.7834581487695687e-05\nfinal w.grad [0.00022115 0.00025191 0.00026335]\ngt w = [ 6.   -0.6   0.06]\ngt b = 6.6\nlearned w = [ 6.0024757  -0.59749424  0.06294169]\nlearned b = 6.6008897\n\"\"\"\n```\n\n用torch的module、optimizer、dataloader重构上面的lr模型\n```python\nimport torch\nimport numpy as np\nfrom torch.utils.data import TensorDataset, DataLoader\n# dataloader\ngt_w = (torch.tensor(np.array([[6, -0.6, 0.06]]).T, \n                device='cpu', dtype=torch.float32))\ngt_b = 6.6\nx = torch.rand(1000, 3)\ny = torch.mm(x, gt_w) + gt_b\ny = y + torch.rand_like(y) * 10e-3\n# dataloader\ndata = TensorDataset(x, y)\ndata_batch = DataLoader(data, batch_size=1000, shuffle=True)\n# moudle\nmodel = torch.nn.Linear(3, 1)\n# optimizer\nloss_fn = torch.nn.functional.mse_loss\noptim = torch.optim.Adam(model.parameters(), lr=0.9)\n# gradient descent \nfor i in range(10000):\n  for x_batch, y_batch in data_batch:\n    pred = model(x_batch)\n    loss = loss_fn(pred, y_batch)\n    loss.backward()\n    optim.step()\n    optim.zero_grad()\n  if i%100==99:\n    print(\"{i}th iter loss:\".format(i=i).ljust(18), loss.item())\n  if loss.item()<10e-6:\n    break\nprint(\"gt w =\", gt_w.detach().numpy().T[0])\nprint(\"gt b =\", gt_b)\nprint(\"learned w =\", model.weight.detach().numpy().T)\nprint(\"learned b =\", model.bias.detach().numpy())\n\n\"\"\"output\n99th iter loss:    0.005614231340587139\ngt w = [ 6.   -0.6   0.06]\ngt b = 6.6\nlearned w = [[ 6.0015745 ]\n [-0.6000941 ]\n [ 0.05913432]]\nlearned b = [6.602816]\n\"\"\"\n```\n\n3. 实践经验\n","tags":["学习笔记","pytorch"]},{"title":"C++容器总结","url":"/2022/03/11/C++/","content":"\n### [STL简介:](geeksforgeeks.org/the-c-standard-template-library-stl)\nC++的标准模板类库，包含常见数据结构及函数。主要包括:\n+ 容器\n+ 算法\n+ 函数（Functions）\n+ 迭代器\n\n### 1. 容器：\n+ 序列式容器:基本的容器\n   + arrays||at();[];front();back();size();empty();fill()||比C自带的数组好\n   + vector||asign();at();[];front();back();begin();end;size();max_size();capacity();resize(n);empty();shrink_to_fit();push_back();pop_back();insert();erase();clear();\n   + forward_list||assign();push_front();emplace_front();pop_front();insert_after();emplace_after(); erase_after(); remove(); remove_if();clear();\n   + deque\n   + list\n   \n+ 容器适配器:序列式容器的扩展\n   + queue\n   + priority_queue\n   + stack\n+ 关联式容器:非序列式容器，基于自平衡二叉树\n   +  set\n   +  multiset\n   +  map\n   +  multimap\n+ 无序关联式容器:非序列式容器，基于哈希表\n   +  unordered_set\n   +  unordered_multiset\n   +  unordered_map\n   +  unordered_multimap\n\n\n### 2. 算法：\n+ sort(startaddress, endaddress)\n","tags":["学习笔记","算法题"]},{"title":"面试算法刷题总结","url":"/2022/02/15/algo/","content":"# 0. 刷题总结\n- 熟悉常用库函数；熟悉数据结构和算法；提高用程序解决复杂问题的能力；提高编程能力和速度。可以参考：[代码随想录](https://www.programmercarl.com/)；[算法小抄](https://github.com/labuladong/fucking-algorithm)。\n- 代码命名、格式、风格参考最佳实践，提高可读性，降低出错率。可以参考：[python最佳实践](https://pythonguidecn.readthedocs.io/zh/latest/)；[C++风格指南](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/)；[C++最佳实践](https://github.com/cpp-best-practices/cppbestpractices)；[腾讯代码安全指南](https://github.com/Tencent/secguide)。\n\n# 1. 算法总结\n### 1.1 算法技巧\n#### 1.1.1 前缀和数组 \n需要频繁计算数组区间和，且数组固定不变：直接转变为前缀和数组,复杂度O(n)>O(1)  \n  [区域和检索](https://leetcode.cn/problems/range-sum-query-immutable/) | [二维区域和检索](https://leetcode.cn/problems/range-sum-query-2d-immutable/)\n#### 1.1.2 差分数组 \n频繁进行区间修改时维护数组的值：转变为差分数组，复杂度O(n)>O(1)  \n[拼车](https://leetcode.cn/problems/car-pooling/) | [航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)\n#### 1.1.3 链表双指针 \n判断/寻找链表中的交点：使用双指针遍历链表并创造条件让指针相遇，空间复杂度O(n)>O(1)  \n[环形链表](https://leetcode.cn/problems/linked-list-cycle/) | [环形链表2](https://leetcode.cn/problems/linked-list-cycle-ii/) | [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\n#### 1.1.4 数组双指针 \n数组寻找受限极值/特定值：发掘单调性规律，让遍历每一步不回头，时间复杂度O(n)>O(1)  \n[有序数组-两数之和](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/) | [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) | [搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix-ii/) | []()\n#### 1.1.5 滑动窗口 \n寻找满足特定条件的最小字串：控制左右边界缩放，让遍历有序，时间复杂度O(n^2)>O(n)  \n[无重复字符的最长字串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) | [串联所有单词的子串\n](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/) | [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) | [包含排列的子串](https://leetcode.cn/problems/permutation-in-string/) | [最小覆盖字串](https://leetcode.cn/problems/minimum-window-substring/) [最短超串](https://leetcode.cn/problems/shortest-supersequence-lcci/) | [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)\n#### 1.1.6  二分搜索 \n有序数组寻找特定值：利用单调性每次查找时剔除一侧的搜索空间，时间复杂度O(n)>O(log(n))  \n[二分查找](https://leetcode.cn/problems/binary-search/) | [二分查找第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) | [送包裹](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/) | [吃香蕉](https://leetcode.cn/problems/koko-eating-bananas/) | [分割数组最大值](https://leetcode.cn/problems/split-array-largest-sum/)、\n#### 1.1.7  单调栈 \n利用单调栈维护最大值，时间复杂度O(n^2)>O(n)  \n[下一个更大的元素](https://leetcode.cn/problems/next-greater-element-i/) | [下一个更大的元素2](https://leetcode.cn/problems/next-greater-element-ii/) | [每日温度](https://leetcode.cn/problems/daily-temperatures/) | [接雨水](https://leetcode.cn/problems/trapping-rain-water/) | [队列中可以看到的人数](https://leetcode.cn/problems/number-of-visible-people-in-a-queue/) | [链表下一个更大的节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/) | [股票价格的跨度](https://leetcode.cn/problems/online-stock-span/) \n| []()\n#### 1.1.7  单调队列\n利用单调队列维护最大值，时间复杂度O(n)>O(1)     \n[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/) | [环形子数组最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)\n#### 1.1.8 并查集\nbalabala\n[被围绕的区域](https://leetcode.cn/problems/surrounded-regions/) | [并查集](https://leetcode.cn/tag/union-find/problemset/)\n\n\n### 1.2 算法思想\n#### 1.2.1 递归\n[二叉树](https://leetcode.cn/tag/binary-tree/problemset/) | [递归](https://leetcode.cn/tag/recursion/problemset/)[图](https://leetcode.cn/tag/graph/problemset/)\n#### 1.2.2 回溯\n[回溯](https://leetcode.cn/tag/backtracking/problemset/) | [bfs](https://leetcode.cn/tag/breadth-first-search/problemset/) | [dfs](https://leetcode.cn/tag/depth-first-search/problemset/)\n#### 1.2.3 贪心\n[贪心](https://leetcode.cn/tag/greedy/problemset/)\n#### 1.2.4 动态规划\n[动态规划](https://leetcode.cn/tag/dynamic-programming/problemset/)\n\n# 2. 题目记录\n很多题目未必包含精巧/通用的算法，而是需要完整的实现功能或者针对性的复杂度优化  \n\n[翻转数组](https://leetcode.cn/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/)  \n在暴力解法的基础上，利用第一行确定整个矩阵，从而压缩搜索空间，降低复杂度。  \n\n[LRU缓存](https://leetcode.cn/problems/lru-cache/)  \n\n[购物单](https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&tqId=21239&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)  \n动态规划01背包的一个变体，每个物体包含多种可能的选择。  \n\n[求解立方根](https://www.nowcoder.com/practice/caf35ae421194a1090c22fe223357dca?tpId=37&tqId=21330&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fdifficulty%3D3%26page%3D1%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=3&judgeStatus=undefined&tags=&title=)  \n二分法或者牛顿法  \n\n[迷宫](https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc?tpId=37&tqId=21266&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fdifficulty%3D3%26page%3D1%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=3&judgeStatus=undefined&tags=&title=)  \n回溯\n","tags":["学习笔记","算法题"]},{"title":"python编程规范、","url":"/2022/02/15/python/","content":"# 1.工程结构\n- 保证仓库结构清晰、易读，如示例1.1所示。\n- 代码间低耦合，无循环依赖，少使用全局变量，少写长函数\n- 拆分出文件（模块）、文件夹（包）；合理使用相对import和绝对import\n- 合理使用面向对象、装饰器、with(上下文管理器；示例1.2)等特性，有利于代码解耦。\n  \n```shell\n#例1.1：仓库结构示例\nREADME\nLICENSE\nsetup.py\nrequirements.txt\ncodes/\n\tmodels/\n\tconfigs/\n\tkernels/\n\tutils/\n\ttrainer/\n\tdatas/\n\ttrain.py\n\ttest.py\n\tinference.py\n\tREADME\ndocs/\ntests/\n``` \n\n```python\n# 例1.2：使用上下文管理的两种方法\n# 定义enter和exit方法实现：\nclass CustomOpen(object):\n    def __init__(self, filename):\n        self.file = open(filename)\n\n    def __enter__(self):\n        return self.file\n\n    def __exit__(self, ctx_type, ctx_value, ctx_traceback):\n        self.file.close()\n\nwith CustomOpen('file') as f:\n    contents = f.read()\n# 使用自带的contextlib实现：\nfrom contextlib import contextmanager\n\n@contextmanager\ndef custom_open(filename):\n    f = open(filename)\n    try:\n        yield f\n    finally:\n        f.close()\n\nwith custom_open('file') as f:\n    contents = f.read()\n```\n  \n  \n\n# 2.代码风格\n  - 在存在各种黑魔法的Python中，我们提倡最明确和直接的编码方式\n  - 在同一行代码中写 两条独立的语句是糟糕的。\n  - 少使用*args定义函数参数,因为它不应该被用在能用更简单和更明确的结构，来足够表达函数意图的情况中。\n  - 任何不开放给客户端代码使用的方法或属性，应该有一个下划线前缀。\n  - 函数只有一个出口点，输入、运行环境的检查建议使用异常机制，见例2.1\n  - 可能运行失败的代码使用异常机制（``try...except``）\n  - 使用上下文管理器管理资源\n  - 使用属性，而不是get/set\n  - 使用``_``命名临时变量\n  - 避免对不同类型的对象使用同一个变量名\n  - string类型是不可变类型，减少内存分配，少使用``s+=str(i)``，可以改成：生成list，再join。\n  - 使用 str.format() 替代 % 操作符。例如：``foobar = '{foo}{bar}'.format(foo=foo, bar=bar)``\n  - 使用``in``进行字串匹配\n  - 使用``enumerate()``进行index计数\n  - 使用next()进行按条件查找\n  - 对于可变序列，使用del替代重新分配``del l[j:] instead of l = l[:j]``\n  - 如果您知道一个列表或者元组的长度，您可以将其解包并为它的元素取名。``a, b, *middle, c = [1, 2, 3, 4]``\n  - 使用filter() 函数过滤list：``sequence[::] = list(filter(lambda i: i != x, sequence))``\n  - 修改list，优先考虑赋值为新的list，如：``a = [i + 3 for i in a] or a = list(map(lambda i: i + 3, a))``\n  - 过长的行一个更好的解决方案是在周围使用括号 ``(·····)``\n  - ``pip install autopep8````autopep8 --in-place optparse.py``\n```python\n#例2.1\ndef complex_function(a, b, c):\n    if not a:\n        return None  # 抛出一个异常可能会更好\n    if not b:\n        return None  # 抛出一个异常可能会更好\n\n    # 一些复杂的代码试着用a,b,c来计算x\n    # 如果成功了，抵制住返回x的诱惑\n    if not x:\n        # 一些关于x的计算的Plan-B\n    return x  # 返回值x只有一个出口点有利于维护代码\n```\n```python\n#例2.2\ntry:\n    x = next(i for i, n in enumerate(l) if n > 0)\nexcept StopIteration:\n    print('No positive numbers')\nelse:\n    print('The index of the first positive number is', x)\n```\n```\n# python之禅\n优美胜于丑陋（Python以编写优美的代码为目标）\n明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）\n简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）\n复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）\n扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）\n间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）\n可读性很重要（优美的代码是可读的）\n即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）\n不要包容所有错误，除非您确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）\n当存在多种可能，不要尝试去猜测\n而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）\n虽然这并不容易，因为您不是 Python 之父（这里的 Dutch 是指 Guido ）\n做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）\n如果您无法向人描述您的方案，那肯定不是一个好方案；反之亦然（方案测评标准）\n命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）\n```\n### 参考资料\n[python最佳实践](https://pythonguidecn.readthedocs.io/zh/latest/)","tags":["学习笔记","python"]},{"title":"简单易用的深度学习算法网络部署方案","url":"/2022/01/29/algorithm-server/","content":"# 1.整体架构  \n整体思路较为简单，主要包括http服务模块和任务管理模块。http服务模块监听指定端口，等待后端的POST请求，收到POST请求后，返回OK给后端并添加计算任务到阻塞队列。任务管理模块并发处理任务队列中的任务，处理完成后回调后端，返回结果。  \n\n本项目基于python3的hhtp.server库实现。  \n\n# 2.代码示例  \n```python  \n\"\"\"\n@author: ygq65536\n简单易用的深度学习算法HTTP服务器程序\n\"\"\"\nimport http.server\nimport json\nimport algorithm_process # 深度学习算法接口\nimport numpy as np\nfrom urllib.request import urlopen\nimport cv2\nimport requests\nfrom multiprocessing import Process\nfrom queue import Queue\nimport logging\n\n\ndef task_process(img_url, task_id, callback_url):\n    \"\"\"下载图片，执行算法，整理结果，回调后端\n    \"\"\"\n    try:\n        resp = urlopen(img_url)\n        image = np.asarray(bytearray(resp.read()), dtype=\"uint8\")\n        image = cv2.imdecode(image, cv2.IMREAD_COLOR)\n        result = algorithm_process(image)\n        result[\"task_id\"] = task_id\n        data_json = json.dumps(result)   #dumps：将python对象解码为json数据\n        headers = {\"Content-Type\":\"application/json\",\n           \"appKey\":\"XXX\",\n           \"appSecret\":\"XXXXXXXXXX\"}\n        callback_resp = requests.post(callback_url, data_json, headers=headers)\n\n    except Exception as ex:\n        return\n\n\n\ndef task_manage(q):\n    \"\"\"队列有任务则调用算法模块处理，否则阻塞\n    \"\"\"\n    while True:\n        try:\n            datas = q.get(block=True)\n            task_id = datas[\"task_id\"]\n            img_url = datas[\"img_url\"]\n            callback_url = datas[\"callback_url\"]\n            task_process(img_url, task_id, callback_url)\n        except Exception as ex:\n            continue\n\nclass algorithm_server(http.server.BaseHTTPRequestHandler):\n    \"\"\"http服务类 监听并异步响应post调用\n    \"\"\"\n    def setup(self):\n        self.request.settimeout(10)\n        http.server.BaseHTTPRequestHandler.setup(self)\n\n    def _set_response(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n\n    def do_GET(self):\n        buf = 'XXXX'\n        self.protocal_version = 'HTTP/1.1'\n        self._set_response()\n        buf = bytes(buf, encoding=\"utf-8\")\n        self.wfile.write(buf)\n\n    def do_POST(self):\n        '''\n        处理通过POST方式传递过来的数据（放入全局任务队列）\n        异步调用模型得到结果并返回\n        '''\n        path = self.path\n        #获取post提交的数据\n        datas = self.rfile.read(int(self.headers['content-length']))\n        datas = datas.decode('utf-8')\n        datas = json.loads(datas)\n        if \"task_id\" in datas:\n            task_id = datas[\"task_id\"]\n        else:\n            buf = '403'\n            buf = bytes(buf, encoding=\"utf-8\")\n            self.wfile.write(buf)\n            return\n        if \"img_url\" in datas:\n            img_url = datas[\"img_url\"]\n        else:\n            buf = '403'\n            buf = bytes(buf, encoding=\"utf-8\")\n            self.wfile.write(buf)\n            return\n        if \"callback_url\" in datas:\n            callback_url = datas[\"callback_url\"]\n        else:\n            buf = '403'\n            buf = bytes(buf, encoding=\"utf-8\")\n            self.wfile.write(buf)\n            return\n        buf = '200'\n        self._set_response()\n        buf = bytes(buf, encoding=\"utf-8\")\n        self.wfile.write(buf)\n        task_queue.put(datas)\n        return\n\ndef start_server(ip, port):\n    http_server = http.server.HTTPServer((ip, int(port)), algorithm_server)\n    try:\n        http_server.serve_forever()  #设置一直监听并接收请求\n    except KeyboardInterrupt:\n        pass\n    http_server.server_close()\n\nif __name__ == '__main__':\n    # 全局任务队列\n    process_num = 8\n    task_queue = Queue(maxsize=0)\n    for _ in range(process_num):\n        Process(target=task_manage, args=(task_queue,)).start()\n    start_server('0.0.0.0', 9753)  # For IPv4 Network Only  \n\n```","tags":["网络后端 python"]},{"title":"Hexo Quick Start","url":"/2021/09/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]